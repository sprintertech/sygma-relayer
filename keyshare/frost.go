// The Licensed Work is (c) 2022 Sygma
// SPDX-License-Identifier: LGPL-3.0-only

package keyshare

import (
	"encoding/json"
	"fmt"
	"os"
	"sync"

	"github.com/libp2p/go-libp2p/core/peer"
	"github.com/taurusgroup/multi-party-sig/pkg/math/curve"
	"github.com/taurusgroup/multi-party-sig/pkg/party"
	"github.com/taurusgroup/multi-party-sig/pkg/taproot"
	"github.com/taurusgroup/multi-party-sig/protocols/frost"
)

type FrostKeyshare struct {
	Key       *frost.TaprootConfig
	Threshold int
	Peers     []peer.ID
}

type frostKey struct {
	ID                 party.ID
	Threshold          int
	PrivateShare       []byte
	PublicKey          taproot.PublicKey
	ChainKey           []byte
	VerificationShares map[party.ID][]byte
}

type frostKeyshareStore struct {
	Key       frostKey
	Threshold int
	Peers     []peer.ID
}

func NewFrostKeyshare(key *frost.TaprootConfig, threshold int, peers []peer.ID) FrostKeyshare {
	return FrostKeyshare{
		Key:       key,
		Threshold: threshold,
		Peers:     peers,
	}
}

type FrostKeyshareStore struct {
	mu   sync.Mutex
	path string
}

func NewFrostKeyshareStore(filePath string) *FrostKeyshareStore {
	return &FrostKeyshareStore{
		path: filePath,
	}
}

// LockKeyshare locks keyshare from reading and writing to
// prevent keygen or resharing being done in parallel with other
// tss processes.
func (ks *FrostKeyshareStore) LockKeyshare() {
	ks.mu.Lock()
}

// UnlockKeyshare unlocks keyshare to allow for tss processes to continue
func (ks *FrostKeyshareStore) UnlockKeyshare() {
	ks.mu.Unlock()
}

// StoreFrostKeyshare stores frost keyshare generated by keygen or reshare into file and truncates
// old keyshare.
func (ks *FrostKeyshareStore) StoreKeyshare(keyshare FrostKeyshare) error {
	f, err := os.OpenFile(ks.path, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)
	if err != nil {
		return err
	}
	defer f.Close()

	privateShareBytes, err := keyshare.Key.PrivateShare.MarshalBinary()
	if err != nil {
		return err
	}
	verificationShares := make(map[party.ID][]byte)
	for id, point := range keyshare.Key.VerificationShares {
		pointBytes, err := point.MarshalBinary()
		if err != nil {
			return err
		}
		verificationShares[id] = pointBytes
	}
	fKey := frostKey{
		ID:                 keyshare.Key.ID,
		Threshold:          keyshare.Key.Threshold,
		PrivateShare:       privateShareBytes,
		PublicKey:          keyshare.Key.PublicKey,
		ChainKey:           keyshare.Key.ChainKey,
		VerificationShares: verificationShares,
	}
	fStore := frostKeyshareStore{
		Key:       fKey,
		Threshold: keyshare.Threshold,
		Peers:     keyshare.Peers,
	}
	kb, err := json.Marshal(&fStore)
	if err != nil {
		return err
	}

	_, err = f.Write(kb)
	return err
}

// GetFrostKeyshare fetches current keyshare from file.
// Can be a blocking call if keygen or resharing are pending.
func (ks *FrostKeyshareStore) GetKeyshare() (FrostKeyshare, error) {
	fStore := frostKeyshareStore{}
	k := FrostKeyshare{}

	kb, err := os.ReadFile(ks.path)
	if err != nil {
		return k, fmt.Errorf("error on reading keyshare file: %s", err)
	}

	err = json.Unmarshal(kb, &fStore)
	if err != nil {
		return k, fmt.Errorf("error on unmarshaling keyshare file: %s", err)
	}
	k.Threshold = fStore.Threshold
	k.Peers = fStore.Peers

	privateShare := &curve.Secp256k1Scalar{}
	err = privateShare.UnmarshalBinary(fStore.Key.PrivateShare)
	if err != nil {
		return k, err
	}
	verificationShares := make(map[party.ID]*curve.Secp256k1Point)
	for id, pointBytes := range fStore.Key.VerificationShares {
		point := &curve.Secp256k1Point{}
		err := point.UnmarshalBinary(pointBytes)
		if err != nil {
			return k, err
		}
		verificationShares[id] = point
	}
	key := &frost.TaprootConfig{
		ID:                 fStore.Key.ID,
		Threshold:          fStore.Key.Threshold,
		PrivateShare:       privateShare,
		PublicKey:          fStore.Key.PublicKey,
		ChainKey:           fStore.Key.ChainKey,
		VerificationShares: verificationShares,
	}
	k.Key = key

	return k, err
}
