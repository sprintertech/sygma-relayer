package keyshare

import (
	"encoding/json"
	"fmt"
	"os"
	"sync"

	"github.com/libp2p/go-libp2p/core/peer"
	"github.com/taurusgroup/multi-party-sig/protocols/frost"
)

type FrostKeyshare struct {
	Key       *frost.TaprootConfig
	Threshold int
	Peers     []peer.ID
}

func NewFrostKeyshare(key *frost.TaprootConfig, threshold int, peers []peer.ID) FrostKeyshare {
	return FrostKeyshare{
		Key:       key,
		Threshold: threshold,
		Peers:     peers,
	}
}

type FrostKeyshareStore struct {
	mu   sync.Mutex
	path string
}

func NewFrostKeyshareStore(filePath string) *FrostKeyshareStore {
	return &FrostKeyshareStore{
		path: filePath,
	}
}

// LockKeyshare locks keyshare from reading and writing to
// prevent keygen or resharing being done in parallel with other
// tss processes.
func (ks *FrostKeyshareStore) LockKeyshare() {
	ks.mu.Lock()
}

// UnlockKeyshare unlocks keyshare to allow for tss processes to continue
func (ks *FrostKeyshareStore) UnlockKeyshare() {
	ks.mu.Unlock()
}

// StoreFrostKeyshare stores frost keyshare generated by keygen or reshare into file and truncates
// old keyshare.
func (ks *FrostKeyshareStore) StoreFrostKeyshare(keyshare FrostKeyshare) error {
	f, err := os.OpenFile(ks.path, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)
	if err != nil {
		return err
	}
	defer f.Close()

	kb, err := json.Marshal(&keyshare)
	if err != nil {
		return err
	}

	_, err = f.Write(kb)
	return err
}

// GetFrostKeyshare fetches current keyshare from file.
// Can be a blocking call if keygen or resharing are pending.
func (ks *FrostKeyshareStore) GetFrostKeyshare() (FrostKeyshare, error) {
	k := FrostKeyshare{}

	kb, err := os.ReadFile(ks.path)
	if err != nil {
		return k, fmt.Errorf("error on reading keyshare file: %s", err)
	}

	err = json.Unmarshal(kb, &k)
	if err != nil {
		return k, fmt.Errorf("error on unmarshaling keyshare file: %s", err)
	}

	return k, err
}
